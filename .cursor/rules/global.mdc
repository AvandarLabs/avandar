---
description: Avandar Labs
globs:
alwaysApply: true
---

# Global Rules

## Codebase information

Directories:

- `src/components`: All React components
- `src/routes`: All router pages
- `src/lib`: Our local library of hooks, utilities, and UI components.
- `src/config`: The application config and theme.
- `src/clients`: Clients to interact with external services.

Libraries:

- Bundler: Vite v7
- Frontend framework: React v19
- UI library: Mantine v8
- Router: Tanstack Router v1
- Querying: Tanstack Query v5
- Schema validation: Zod v4
- Database and Auth: Supabase JS v2
- Linter: ESLint v9
- Formatter: Prettier v3
- CSS Styles: TailwindCSS v3
- Icons: Tabler Icons v3

## Library usage

- Always use the Context7 MCP to reference the most up-to-date documentation for
  any library listed here.
- Use the library versions referenced in this document. Do not look up
  documentation from older versions.
- If an external library import shares a name with one of our files in our local
  library in `src/lib/**`, import our local version instead of the external
  library. For example:
  - Import `useQuery` from `@/lib/hooks/query/useQuery`.
  - Import `Link` components from `@/lib/ui/links/`.
  - Import utility functions from `@/lib/utils/`.

## React-query

- Use our `useQuery` and `useMutation` wrappers from `@/lib/hooks/query` instead
  of importing from `@tanstack/react-query`

## Mantine

- Use our `useForm` wrapper in `@/lib/hooks/ui` instead of using Mantine's
  `useForm` directly.
- Before using any Mantine component, check if we don't already have a wrapper
  for it in `src/lib/ui`. If we do, import our wrapper instead.
- When using `useForm`, always set a `key={form.key('fieldId')}` prop
  to each input component even if they are not in an array.

## General Code Style & Formatting

- Always declare the types of each variable, function, parameters, and return
  values that are at the top level of a file or at a module boundary.
  - Local variables within a function do not need type declarations.
  - A nested function (e.g. an arrow function inside another function) does not
    need to have its parameters or return types annotated.
    declarations.
- Use JSDoc to document public classes and methods.
- Use functional and declarative programming patterns. Avoid classes.
- Use higher-order functions (map, filter, reduce) to simplify logic.
  Avoid `for` and `while` loops.
- Always use named exports instead of default exports.
- **Never** exceed 80 characters per line, including comments.
- Leave an empty line before any comments or docstrings.
- If a docstring fits in 80 characters, then single-line it. Example:

  ```ts
  /** my single-line comment less than 80 characters*/.
  ```

- Never use single-line `if`s. Always use opening `{` and closing `}` even if
  there is only one statement to wrap. Examples:

  ```ts
  // This is bad:
  if (someCondition) doSomething();

  // This is good:
  if (someCondition) {
    doSomething();
  }
  ```

## Naming Conventions

- Use PascalCase for React components, classes, singleton class instances, or
  objects representing modules, namespaces, or static singletons.
- Use camelCase for variables, functions, and methods.
- Use UPPERCASE for environment variables or hard-coded constants.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading,
  hasError).
- Event handlers should be prefixed with `on` (E.g. Good: `onSubmit`) instead of
  `handle` (e.g. Bad: `handleSubmit`).
- Avoid abbreviated names, such as `val`, use the full word `value`. Only
  exception is when it would collide with another variable name in the same
  scope.
- Avoid vague names like `next`, `prev`, or `n`, that don't say what the
  variable actually actually holds. Always include a noun, such as `nextPage`,
  `prevRow` or `numPeople`.
- Always name a React component's props just `Props`. Do not name props after
  the component, such as `MyComponentProps`.

## File, Directory, and Module Conventions

- If you create a new directory for a function or component, then use a small
  barrel file to export it. For example:

  ```plaintext
  MyComponent
    | index.tsx
    | MyComponent.tsx
    | MyComponent.test.tsx
  ```

  The `index.tsx` should **only** export what is intended to be imported by
  other parts of the codebase. Think of it as a public interface. Any functions
  that were used only in this directory should not be publicly exported in
  the barrel file.

- Never create monolithic barrel files. The only types of barrel files we allow
  are the small, modular, barrel files described above.
- Never use `export * from ...`. Always explicitly name your exports, e.g.
  `export { MyComponent } from ...`.
- Types should always be imported or exported with the `type` keyword, e.g.

  ```ts
  import type { MyType } from ...;
  export type { MyType } from ...;
  ```

## Functions & Logic

- Keep functions short and single-purpose (< 30 lines).
- Avoid deeply nested blocks by:
  - Using early returns.
  - Extracting logic into utility functions.
- Use default parameter values instead of null/undefined checks.
- Use `undefined` instead of `null` except when an API requires `null`.
  For example: JSON in HTTP requests; returning `null` in React to skip render.
- Use RO-RO (Receive Object, Return Object) for passing and returning multiple
  parameters (only when there is more than one parameter).
  - If there is only one parameter, accept it directly without wrapping it in
    an object.
  - If you do wrap multiple parameters in an object, default to naming the
    argument as `options`.
- Top-level functions should always use the `function` keyword. Nested functions
  (inside a function or as an object parameter) should always be arrow functions.
- Never use instantly-applied anonymous functions to assign a value to a
  variable. Instead, extract the logic to a named function. For example:

  ```ts
  // This is bad
  const someVal = (() => {
    return complicatedEvaluation();
  })();

  // this is good
  function getComplicatedResult() {
    // do complicated operations here...
    return finalVal;
  }
  const someVal = getComplicatedResult();

  // this is good (if in a nested function)
  function MyComponent() {
    const getComplicatedResult = () => {
      // do complicated operations here...
      return finalVal;
    };
    const someVal = getComplicatedResult();
    // ...
  }
  ```

## TypeScript Best Practices

- Do not use `any`.
- Use `type` instead of `interface`. **Only** use `interface` when it represents
  a traditional OOP `interface` to be implemented by a class.
- Use string literal unions instead of enums.
- Avoid excessive use of primitive types; encapsulate data in composite types.
- Use local mutability and global immutability.
  - Local variables can be mutable. However, any data that crosses module
    boundaries (e.g. React props) should be immutable.
  - For cross-module immutability: use `readonly` for arrays, `Readonly<>` for
    objects, `ReadonlySet` for sets, and `ReadonlyMap` for maps.
  - Use `as const` for literals that never change.

## React Code Style

- One component per file.
- Define functional components with the function keyword instead of arrow
  functions. For example:

  ```ts
  // This is bad:
  const MyComponent = () => {};

  // This is good:
  function MyComponent() {}
  ```

- Use ternaries for conditional rendering instead of short-circuited
  evaluations. For example:

  ```ts
  // This is bad:
  <div>{someCondition && <MyComponent />}</div>

  // This is good:
  <div>{someCondition ? <MyComponent /> : null}</div>
  ```

## Data Fetching and Handling

- Use our internal `useQuery` and `useMutation` wrappers of Tanstack Query
  for frontend data fetching and mutations.
- Use Zod for validation

## Styling & UI

- Ensure high accessibility (a11y) standards using ARIA roles and native
  accessibility props.
- Use Mantine themes and props for styling instead of TailwindCSS. Only use
  TailwindCSS when Mantine's design tokens and props cannot do what we need.

## Icons

- Use `@tabler/icons-react`

## .sql files and schemas

- Use `snake_case` naming conventions
- Tables should be plural (e.g. `profiles` preferred over `profile`)
- Functions should be prefixed with a namespace, either `util__` for utility
  functions or `table_name__` for functions pertaining to a specific table.
- Triggers should be prefixed with `tr__table_name__` for the table it pertains
  to.
